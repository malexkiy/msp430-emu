# msp430-emu
# Теоретические сведения

Эмулятор - комплекс программных, аппаратных средств или их сочетание, который позволяет одной вычислительной системе иммитировать поведение другой вычислительной системы. Целью эмуляции является максимально точное воспроизведение поведения эмулируемой системы.

В качестве эмулируемой системы выбран микроконтроллер __MSP430G2553__ семейства __MSP430__.
Данное семейство микроконтроллеров получило широкое распространение благодаря возможности тактировать любой модуль периферии асинхронно от ядра. Такая особенность позволяет гибко управлять скоростью (а значит, и потреблением) каждого модуля.

Разработка эмуляторов MSP430 производилась и ранее, на различных языках программирования (Python, C/C++, JS и др.), некоторые из них представлены ниже:
 - https://github.com/cemeyer/msp430-emu-uctf
 - https://github.com/pmarkowsky/msp430-emu
 
Основной идеей различных реализаций является размещение регистров процессора и всего адресного пространства в оперативной памяти. В зависимости от подхода программирования работа с ними может быть как инкапсулирована, так и нет.

# Сведения о процессоре

MSP430 имеет фоннеймановскую архитектуру, с единым адресным пространством для команд и данных. Память может адресоваться как побайтово, так и пословно. Порядок хранения 16-разрядных слов - little-endian (от младшего к старшему).

## Регистры

Центральный процессор содержит шестнадцать 16-битных регистров. Регистры R0, R1, R2 и R3 имеют специальные функции. Регистры с R4 по R15 являются рабочими регистрами общего назначения.

__Регистр R0__ используется как программный счетчик (___Program Counter - PC___). PC указывает на следующую инструкцию, которая будет выполнена. Каждая инструкция использует чётное число байт (2, 4 или 6), соответсвенно инкрементируется и значение регистра PC. Доступ к инструкциям в 64-КБ адресном пространстве выполняется пословно, и значение PC выровнено по чётным адресам.

Формат счётчика команд PC приведён ниже:

| 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 | 0 |
| :---------------------------------: | :-: |
|                  PC                 | 0 |

__Регистр R1__ используется как указатель стека (___Stack Pointer - SP___).
Указатель стека (SR/R1) используется процессором для хранения адресов возврата при вызове подпрограмм и обработке прерываний.
Он использует схему предекремента и постинкремента. Кроме того, SP может быть использован программой со всеми инструкциями и режимами адресации. SP инициализируется пользователем в ОЗУ и выровнен по чётным адресам.

Формат указателя стека SP приведён ниже:

| 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 | 0 |
| :---------------------------------: | :-: |
|                  SP                 | 0 |

__Регистр R2__ используется как регистр состояния (___Status Register - SR___).
Регистр состояния (SR/R2) используется в качестве регистра источника или назначения, а также может быть использован в качетве регистра общего назначения, но только с инструкциями, адресуемыми пословно. Остальные комбинации режимов адресации используются для генератора констант.

Формат реситра состояния SR приведён ниже:

| 15 14 13 12 11 10 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
| :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
| Зарезервировано | V | SCG1 | SCG0 | OSC_OFF | CPU_OFF | GIE | N | Z | C |

|   Бит   | Описание |
|   :-:   | -------- |
|    V    | Флаг переполнения. Этот бит устанавливается, если результат арифметической операции  выходит за границы допустимых значений для знаковых величин|
|  SCG1   | Системный тактовый генератор 1. Когда этот бит установлен, сигнал SMCLK отключён |
|  SCG0   | Системный тактовый генератор 0. Когда этот бит установлен, генератор DCO выключен,  если сигнал DCOCLK не используется для формирования сигналов MCLK или SMCLK |
| OSC_OFF | Выключение генератора. Когда этот бит установлен, кварцевый генератор LFXT1 выключен,  если сигнал LFXT1CLK не используется для формирования сигналов MCLK или SMCLK |
| CPU_OFF | Выключение ЦПУ. Когда этот бит установлен, ЦПУ выключено |
|   GIE   | Общий бит разрешения прерываний. Когда этот бит установлен, маскируемые прерывания разрешены. После сброса все маскируемые прерывания запрещены |
|    N    | Флаг отрицательного результата. Этот бит устанавливается, если результат арифметической операции отрицателен, и сбрасывается, если результат положителен |
|    Z    | Флаг нуля. Этот бит устанавливается, если результат арифметической операции равен нулю, и сбрасывается в противном случае |
|    C    | Флаг переноса. Этот бит устанавливается, если при выполнении арифметической операции возникает перенос, и сбрасывается, если переноса не возникает |

__Регистр R3__ используется как специальный регистр, именуемый генератором констант (___Constant Generator - CG___). R2 также может использоваться в качестве генератора констант. Генератор констант используется для сокращения общей длины команды вследствие неявного представления константы в коде операции. Шесть общеиспользуемых констант генерируются с помощью регистров генератора констант R2 и R3 без требования дополнительного 16-битного слова программного кода. Выбор констант производится через адресный режим регистра-источника.

| Регистр | As | Константа | Примечание |
| :-----: | :-: | :------: | --------- |
|    R2   | 00  |    -     | Регистровый режим адресации |
|    R2   | 01  |   (0)    | Абсолютный режим адресации |
|    R2   | 10  |  00004h  | +4, операции над битами |
|    R2   | 11  |  00008h  | +8, операции над битами |
|    R3   | 00  |  00000h  | 0, операции над словами |
|    R3   | 01  |  00001h  | +1 |
|    R3   | 10  |  00002h  | +2, операции над битами |
|    R3   | 11  |  0FFFFh  | –1, операции над словами |

Двенадцать регистров с R4 по R15 являются регистрами общего назначения. Любой из этих регистров может использоваться в качестве регистра данных, указателя или индексного значения. Все эти регистры доступны для команд, работающих как с однобайтными, так и с двухбайтными операндами.

## Режимы адресации

ЦПУ поддерживает семь режимов адресации для операндов-источников и четыре режима — для операндов-приёмников. Эти режимы позволяют адресовать любые ячейки в пределах адресного пространства. В таблице приводятся значения битов режима As (для операнда-источника) и Ad (для операнда-приёмника), соответствующие тому или иному режиму адресации.

|  As/Ad  | Режим адресации | Синтаксис | Описание |
| :-----: | ---------------------------------------- | :-----: | ------- |
|   00/0  | Регистровый                              |  Rn     | Содержимое регистра является операндом |
|   01/1  | Индексный                                |  X(Rn)  | (Rn + X) указывает на операнд. Значение X содержится в следующем слове |
|   01/1  | Относительный                            |  ADDR   | (PC + X) указывает на операнд. Значение X содержится в следующем слове. Используется индексный режим адресации X(PC) |
|   01/1  | Абсолютный                               |  &ADDR  | Слово, следующее за командой, содержит абсолютный адрес. Значение X содержится в следующем слове. Используется индексный режим адресации X(SR) |
|   10/-  | Косвенный регистровый                    |  @Rn    | Rn используется в качестве указателя на операнд |
|   11/-  | Косвенный регистровый с автоинкрементом  |  @Rn+   | Rn используется в качестве указателя на операнд. После выполнения операции значение регистра Rn увеличивается на 1 для команд с однобайтными операндами (.B) и на 2 для команд с двухбайтными операндами (.W) |
|   11/-  | Непосредственный                         |  #N     | Слово, следующее за командой, содержит значение константы N. Используется косвенный режим адресации с автоинкрементом @PC+ |

## Система команд

В общей сложности набор команд ЦПУ MSP430 включает в себя 27 команд ядра и 24 эмулируемых команды. Команды ядра — это команды, которые имеют уникальные коды операций, декодируемые ЦПУ. Эмулируемые команды облегчают создание и чтение кода, но не имеют собственных кодов операций, а автоматически заменяются ассемблером на эквивалентные команды ядра.

| | |
| :- | :- |
| src | Операнд-источник, определяемый битами As и S-reg |
| dst | Операнд-приёмник, определяемый битами Ad и D-reg |
| As | Биты, определяющие режим адресации источника (src) |
| S-reg | Рабочий регистр, используемый в качестве источника (src) |
| Ad | Биты, определяющие режим адресации приёмника (dst) |
| D-reg | Рабочий регистр, используемый в качестве приёмника (dst) |
| B/W | Одно- или двухбайтная операция: <br> 0 — двухбайтная операция <br> 1 — однобайтная операция |

Адрес назначения может быть любым в пределах адресного пространства. Тем не менее, при использовании команды, изменяющей содержимое приёмника, необходимо убедиться, что адрес назначения доступен для записи. К примеру, адрес, находящийся в диапазоне адресов масочного ПЗУ, будет корректным адресом назначения, однако его содержимое не может быть изменено, поэтому результат выполнения команды будет утерян.

Существует три формата команд ядра:
- команды с двумя операндами;
- команды с одним операндом;
- команды перехода.

Все одно- и двухоперандные команды могут работать как с однобайтными, так и с двухбайтными значениями. Команды, оперирующие байтами, используются для работы с однобайтными данными или доступа к 8-битным периферийным модулям. Команды, оперирующие словами, используются для работы с двухбайтными данными или доступа к 16-битным периферийным модулям.

# Входные данные
На вход программы поступает бинарный файл (образ прошивки для микроконтроллера MSP430G2553).
Прошивка, написанная на языке программирования C, компилируется в IDE IAR MSP430 с последующим преобразованием в формат RAW Binary.
Формат файла RAW Binary представляет из себя образ прошивки, в том виде, как она располагается в адресном пространстве микроконтроллера (секции кода, констант, данных). Первое 16-битное слово в файле является начальным значением PC (точка входа).

# Выходные данные
В выходной текстовый файл производится запись состояния процессора после выполнения очередной инструкции (___running___, если микроконтроллер продолжает работу или ___halt___, если прекратил, а также значения всех регистров в шестнадцатеричном виде).

### Пример: 
___CPU state: running___

___PC:  C004 SP:  0400 SR:  0000 CG2: 0000___

___R4:  0000 R5:  0000 R6:  0000 R7:  0000___

___R8:  0000 R9:  0000 R10: 0000 R11: 0000___

___R12: 0000 R13: 0000 R14: 0000 R15: 0000___

# План решения задания:
- изучение набора команд MSP430
- написание функций, эмулирующих команды ядра
- написание функций, эмулирующих работу процессора
- написание тестовых программ для MSP430

Эмулятор микроконтроллера написан на языке C++ и состоит из двух частей - _отладчика_ и _процессора_.

## Процессор

### Регистры

Регистры процессора представлены в виде следующей структуры:

```c++
typedef struct _regs Registers_t;
struct _regs {
	union {
		uint16_t R[16];
		struct {
			uint16_t PC;
			uint16_t SP;
			union {
				uint16_t SR_;
				struct {
					uint16_t C : 1;
					uint16_t Z : 1;
					uint16_t N : 1;
					uint16_t GIE : 1;
					uint16_t CPU_OFF : 1;
					uint16_t OSC_OFF : 1;
					uint16_t SCG0 : 1;
					uint16_t SCG1 : 1;
					uint16_t V : 1;
					uint16_t _reserved : 7;
				} SR;
			};
			uint16_t CG2;
		};
	};

	const uint32_t _count = 16;
};
```

Доступ к регистрам осуществляется внутри приватных методов класса процессора.

### Адресное пространство

Адресное простарнство данного процессора относительно мало (всего 64КБ), поэтому для него выделяется единый блок памяти размером 64КБ. Работа с адресным пространством осуществляется при помощи класса ___Memspace___. Данный класс предоставляет следующие методы: ___addr_ptr___, ___stack_ptr___, ___code_ptr___, ___code_size___.

Метод ___addr_ptr___ вычисляет и возвращает указатель на область памяти виртуального адресного пространства. На вход принимает виртуальный адрес.

Метод ___stack_ptr___ вычисляет и возвращает указатель на область памяти виртуального адресного пространства секции стека. На вход принимает виртуальный адрес.

Метод ___code_ptr___ вычисляет и возвращает указатель на область памяти виртуального адресного пространства секции кода. На вход принимает виртуальный адрес.

Метод ___code_size___ возвращает размер секции _'.code'_.

Последние два метода используются только при загрузке прошивки.

### Ядро

Конкретный процессор (в данном случае __MSP430G2553__) реализуется классом ___MSP430___, который в свою очередь наследуется от абстрактного класса ___Cpu___. Класс ___Cpu___ содержит в себе объекты для регистров процессора (структура ___Registers_t___) и его адресного пространства (класс ___Memspace___).

Класс ___MSP430___ переопределяет методы ___load_fw___, ___step___, ___decode___ и ___fetch___, унаследованные от класса ___Cpu___ в соответствии с реальным поведением эмулируемого процессора. А также реализует команды ядра и функции декодирования команд каждого из форматов в виде приватных методов.

Команды формата 1 в качетве аргументов принимают указатели на операнды _src_ и _dst_ и длину команды, команды формата 2 - указатель на операнд _src_ и длину команды, команды формата 3 - значение смещения относительно PC.

Метод ___load_fw___ загружает из бинарного файла прошивку микроконтроллера в (виртуальное) адресное простарнство, начиная с адреса ___0xC000___. Именно с этого адреса начинается выполнение программы.

Метод ___step___ извлекает из памяти по адресу PC команду и выполняет её, при помощи методов ___fetch___ и ___decode___ соответсвенно.

Метод ___fetch___ возвращает 16-битное значение, расположенное по указанному адресу (он передаётся в качестве аргумента), и увеличивает значение PC на 2.

Метод ___decode___ осуществляет декодирование и выполнение команды в зависимости от ёё формата. У данного микроконтроллера три формата команд. Обработка каждого из них выполняется при помощи соответсвующих приватных методов: ___formatI___, ___formatII___, ___formatJ___.

Метод ___formatI___ вычисляет значение операнда-источника и/или адрес виртуального адресного пространства, по которому расположен операнд (который по факту является указателем на него), в зависимости от режима адресации, а также указатель на операнд-приёмник. И затем вызывает функцию, эмулирующую декодируемую команду, с передачей указателей на операнды и длины команды.

Метод ___formatII___ вычисляет значение операнда-источника и/или адрес виртуального адресного пространства, по которому расположен операнд (который по факту является указателем на него), в зависимости от режима адресации. И затем вызывает функцию, эмулирующую декодируемую команду, с передачей указателя на операнд и длины команды.

Метод ___formatJ___ вычисляет смещение относительно PC и вызывает одну из функций перехода, в зависимости от условия.

Функции, ___step___, ___decode___, ___formatI___, ___formatII___ и ___formatJ___ возвращают _true_ или _false_ в случае успеха или неудачи декодирования и выполнения команды соответственно.

## Отладчик

_Отладчик_ используется для управления процессором (вызов функции для выполнения следующей инструкции) и вывода состояния процессора. Данный элемент системы реализуется классом ___Debugger___ и предоставляет следующие методы: ___step___ и ___print_cpu_state___.

Метод ___step___ вызывает метод ___step___ класса ___Cpu___ и возвращает результат его работы.

Метод ___print_cpu_state___ выводит в поток ```std::ostream``` информацию о процессоре. ___CPU state: running___, если микроконтроллер продолжает работу или ___CPU state: halt___, если прекратил, а также значения всех регистров в шестнадцатеричном виде.

## Эмулятор

Эмулятор реализуется классом ___Emulator___, он содержит всего лишь один метод - ___run___.

Метод ___run___ принимает на вход две строки - первая содержит имя файла прошивки, вторая - имя выходного файла.
Внутри данного метода происходит вызов метода загрузки прошивки и её последующее выполнение.

Код эмулятора представлен ниже:

```c++
#include "emulator.h"


int main(int argc, char* argv[])
{
	if (argc == 3)
	{
		Emulator emul;

		emul.run(argv[1], argv[2]);
	}

	return 0;
}

```

```c++
//...

void Emulator::run(const std::string& fw_file, const std::string& log_file)
{
	bool is_running = true;
	std::ofstream out(log_file);

	_cpu->load_fw(fw_file);

	_dbgr->print_cpu_state(out);
	while (is_running)
	{
		is_running = _dbgr->step();
		_dbgr->print_cpu_state(out);
	}

	out.close();
}
```

# Подробное описание системы команд

Ниже перечислены форматы команд ядра, сами команды и описание их выполнения.

Как было сказано выше, MSP430 имеет три формата команд ядра:
- команды с двумя операндами;
- команды с одним операндом;
- команды перехода.

## Формат команд с двумя операндами: 
| 15 14 13 12 | 11 10 9 8 | 7 | 6 | 5 4 | 3 2 1 0 |
| :---------: | :-------: | :-: | :-: | :-: | :-------: |
|   op-code   |   s-reg   | ad | b/w | as | d-reg |


### Перечень команд:
- MOV
- ADD
- ADDC
- SUB
- SUBC
- CMP
- DADD
- BIT
- BIC
- BIS
- XOR
- END

## Формат команд с одним операндом: 
| 15 14 13 12 11 10 9 8 7 | 6 | 5 4 | 3 2 1 0 |
| :---------------------: | :-: | :-: | :---: |
|         op-code         | b/w | ad | ds-reg |


### Перечень команд:
- RRC
- RRA
- PUSH
- SWPB
- CALL
- RETI
- SXT

## Формат команд перехода: 
| 15 14 13 | 12 11 10 | 9 8 7 6 5 4 3 2 1 0 |
| :------: | :------: | :-----------------: |
| op-code | condition |  10-bit PC offset   |


### Перечень команд:
- JEQ/JZ
- JNE/JNZ
- JC
- JNC
- JN
- JGE
- JL
- JMP

Команды условного перехода осуществляют относительный переход по заданному смещению и не влияют на биты состояния ЦПУ. Переход может осуществляться в пределах от –511 до +512 слов относительно текущего значения PC. Величина смещения интерпретируется как 10-битное значение со знаком, которое удваивается и прибавляется к содержимому счётчика команд: 
PC [new] = PC [old] + 2 + PC [offset] * 2

## Описание команд: 
### MOV

__Операция:__ src → dst

__Описание:__ Операнд-источник пересылается в операнд-приёмник. Содержимое операнда-источника не изменяется. Предыдущее содержимое операнда-приёмника теряется.

__Биты состояния:__ не изменяются

### ADD

__Операция:__ src + dst → dst

__Описание:__ Операнд-источник прибавляется к операнду-приёмнику. Содержимое операнда-источника не изменяется. Предыдущее содержимое операнда-приёмника теряется.

__Биты состояния:__

N: Устанавливается, если результат отрицательный, сбрасывается — если положительный.

Z: Устанавливается, если результат нулевой, иначе сбрасывается.

C: Устанавливается, если произошёл перенос, иначе сбрасывается.

V: Устанавливается, если произошло переполнение, иначе сбрасывается.

### ADDC

__Операция:__ src + dst + C → dst

__Описание:__ Операнд-источник и бит переноса (C) прибавляются к операнду-приёмнику. Содержимое операнда-источника не изменяется. Предыдущее содержимое операнда-приёмника теряется.

__Биты состояния:__

N: Устанавливается, если результат отрицательный, сбрасывается — если положительный.

Z: Устанавливается, если результат нулевой, иначе сбрасывается.

C: Устанавливается, если произошёл перенос из старшего бита результата, иначе сбрасывается.

V: Устанавливается, если произошло переполнение, иначе сбрасывается.

### SUB

__Операция:__ dst + .NOT.src + 1 → dst

__Описание:__ Операнд-источник вычитается из операнда-приёмника путём прибавления к последнему обратного кода операнда-источника плюс единица. Содержимое операнда-источника не изменяется. Предыдущее содержимое операнда-приёмника теряется.

__Биты состояния:__

N: Устанавливается, если результат отрицательный, сбрасывается — если положительный.

Z: Устанавливается, если результат нулевой, иначе сбрасывается.

C: Устанавливается, если произошёл перенос из MSB результата, иначе сбрасывается. Устанавливается, если не было заёма, иначе сбрасывается.

V: Устанавливается, если произошло переполнение, иначе сбрасывается.

### SUBC

__Операция:__ dst + .NOT.src + C → dst

__Описание:__ Операнд-источник вычитается из операнда-приёмника путём прибавления к последнему обратного кода операнда-источника и значения бита переноса. Содержимое операнда-источника не изменяется. Предыдущее содержимое операнда-приёмника теряется.

__Биты состояния:__

N: Устанавливается, если результат отрицательный, сбрасывается — если положительный.

Z: Устанавливается, если результат нулевой, иначе сбрасывается.

C: Устанавливается, если произошёл перенос из MSB результата, иначе сбрасывается. Устанавливается, если не было заёма, иначе сбрасывается.

V: Устанавливается, если произошло переполнение, иначе сбрасывается.

### CMP

__Операция:__ dst + .NOT.src + 1

__Описание:__ Операнд-источник вычитается из операнда приёмника. Для выполнения этой операции обратный код операнда-источника плюс 1 складывается с операндом-приёмником. Операнды не изменяются, результат операции не сохраняется — операция влияет только на биты состояния.

__Биты состояния:__

N: Устанавливается, если результат отрицательный (src ≥ dst), сбрасывается — если положительный.

Z: Устанавливается, если результат нулевой, иначе сбрасывается (src = dst).

C: Устанавливается, если был перенос из MSB результата, иначе сбрасывается.

V: Устанавливается, если произошло переполнение, иначе сбрасывается.

### DADD

__Операция:__ src + dst + C → dst (BCD-арифметика)

__Описание:__ Операнд-источник и бит переноса (C) прибавляются к операнду-приёмнику по правилам двоично-десятичной арифметики. Содержимое операнда-источника не изменяется. Предыдущее содержимое операнда-приёмника теряется. Для не BCD-чисел результат операции не определён.

__Биты состояния:__

N: Устанавливается, если MSB результата равен 1, иначе сбрасывается.

Z: Устанавливается, если результат нулевой, иначе сбрасывается.

C: Устанавливается, если результат больше 9999, иначе сбрасывается. Устанавливается, если результат больше 99, иначе сбрасывается.

V: Не определён.

### BIT

__Операция:__ src .AND. dst

__Описание:__ Выполняется операция «Логическое И» между операндом-источником и операндом-приёмником. Результат операции влияет только на биты состояния. Операнды не изменяются.

__Биты состояния:__

N: Устанавливается, если MSB результата равен 1, иначе сбрасывается.

Z: Устанавливается, если результат нулевой, иначе сбрасывается.

C: Устанавливается, если результат ненулевой, иначе сбрасывается.

V: Сбрасывается.

### BIC

__Операция:__ .NOT.src .AND. dst → dst

__Описание:__ Выполняется операция «Логическое И» между инвертированным значением операнда-источника и операндом-приёмником. Результат помещается в операнд-приёмник. Операнд-источник не изменяется.

__Биты состояния:__ не изменяются

### BIS

__Операция:__ src .OR. dst → dst

__Описание:__ Выполняется операция «Логическое ИЛИ» между операндом-источником и операндом-приёмником. Результат помещается в операнд-приёмник. Операнд-источник не изменяется.

__Биты состояния:__ не изменяются

### XOR

__Операция:__ src .XOR. dst → dst

__Описание:__ Выполняется операция «Исключающее ИЛИ» между операндом-источником и операндом-приёмником. Результат помещается в операнд-приёмник. Операнд-источник не изменяется.

__Биты состояния:__

N: Устанавливается, если MSB результата равен 1, иначе сбрасывается.

Z: Устанавливается, если результат нулевой, иначе сбрасывается.

C: Устанавливается, если результат ненулевой, иначе сбрасывается (= .NOT.Zero).

V: Устанавливается, если оба операнда отрицательные.

### AND

__Операция:__ src .AND. dst → dst

__Описание:__ Выполняется операция «Логическое И» между операндом-источником и операндом-приёмником. Результат помещается в операнд-приёмник.

__Биты состояния:__

N: Устанавливается, если MSB результата равен 1, иначе сбрасывается.

Z: Устанавливается, если результат нулевой, иначе сбрасывается.

C: Устанавливается, если результат ненулевой, иначе сбрасывается (= .NOT. Zero).

V: Сбрасывается.

#
### RRC

__Операция:__ C → MSB → MSB-1 ... LSB+1 → LSB → C

__Описание:__ Содержимое операнда-приёмника сдвигается вправо на один бит. Бит переноса (C) вдвигается в старший бит (MSB) операнда, а младший бит операнда (LSB) выдвигается в бит переноса (C).

__Биты состояния:__

N: Устанавливается, если результат отрицательный, сбрасывается — если положительный.

Z: Устанавливается, если результат нулевой, иначе сбрасывается.

C: Загружается из LSB.

V: Сбрасывается.

### RRA

__Операция:__ MSB → MSB, MSB → MSB-1, ... LSB+1 → LSB, LSB → C

__Описание:__ Содержимое операнда-приёмника сдвигается вправо на один бит. Старший бит содержимого (MSB) вдвигается в бит MSB-1 (значение MSB остаётся неизменным), а бит LSB+1 вдвигается в младший бит (LSB).

__Биты состояния:__

N: Устанавливается, если результат отрицательный, сбрасывается — если положительный.

Z: Устанавливается, если результат нулевой, иначе сбрасывается.

C: Загружается из LSB.

V: Сбрасывается.

### PUSH

__Операция:__

SP - 2 → SP

src → @SP

__Описание:__ Указатель стека уменьшается на 2, после чего содержимое операнда-источника помещается в ОЗУ по адресу, определяемому указателем стека (TOS).

__Биты состояния:__ не изменяются

### SWPB

__Операция:__ Bits 15 to 8 ↔ bits 7 to 0

__Описание:__ Старший и младший байты операнда-приёмника меняются местами.

__Биты состояния:__ не изменяются

### CALL

__Операция:__

dst → tmp (dst вычисляется и запоминается)

SP - 2 → SP

PC → @SP (PC сохраняется в стеке)

tmp → PC (dst загружается в PC)

__Описание:__ Осуществляется вызов подпрограммы, расположенной по любому адресу в пределах 64 КБ. Адрес возврата (адрес следующей команды) сохраняется в стеке. В команде используется 2-байтный операнд.

__Биты состояния:__ не изменяются

### RETI

__Операция:__

TOS → SR

SP + 2 → SP

TOS → PC

SP + 2 → SP

__Описание:__ Содержимое регистра состояния восстанавливается таким, каким оно было при входе в процедуру обработки прерывания. Для этого значение, расположенное на вершине стека (TOS), копируется в регистр состояния. Затем указатель стека увеличивается на 2.

Содержимое счётчика команд восстанавливается таким, каким оно было на момент принятия запроса прерывания. Для этого значение, расположенное на вершине стека (TOS), копируется в счётчик команд. Затем указатель стека увеличивается на 2.

__Биты состояния:__ восстанавливаются из стека

### SXT

__Операция:__ Bit 7 → Bit 8 ... Bit 15

__Описание:__ Знаковый бит младшего байта слова копируется во все биты старшего байта.

__Биты состояния:__

N: Устанавливается, если результат отрицательный, сбрасывается — если положительный.

Z: Устанавливается, если результат нулевой, иначе сбрасывается.

C: Устанавливается, если результат ненулевой, иначе сбрасывается (= .NOT.Zero).

V: Сбрасывается.

#
### JEQ/JZ

__Операция:__

Если Z = 1, то PC + 2 × offset → PC

Если Z = 0, то выполняется следующая команда.

__Описание:__ Проверяется бит нуля (Z) регистра состояния. Если он установлен, то смещение (10-битное число со знаком), находящееся в младших битах слова команды, прибавляется к счётчику команд. Если бит Z сброшен, то выполняется команда, следующая за командой перехода.

__Биты состояния:__ не изменяются

### JNE/JNZ

__Операция:__

Если Z = 0, то PC + 2 × offset → PC

Если Z = 1, то выполняется следующая команда.

__Описание:__ Проверяется бит нуля (Z) регистра состояния. Если он сброшен, смещение (10-битное число со знаком), то находящееся в младших битах слова команды, прибавляется к счётчику команд. Если бит Z установлен, то выполняется команда, следующая за командой перехода.

__Биты состояния:__ не изменяются

### JC

__Операция:__

Если C = 1, то PC + 2 × offset → PC

Если C = 0, то выполняется следующая команда.

__Описание:__ Проверяется бит переноса (C) регистра состояния. Если он установлен, то смещение (10-битное число со знаком), находящееся в младших битах слова команды, прибавляется к счётчику команд. Если бит C сброшен, то выполняется команда, следующая за командой перехода. Команда JC (переход по «перенос»/«выше или равно») используется при сравнении чисел без знака (от 0 до 65535).

__Биты состояния:__ не изменяются

### JNC

__Операция:__

Если С = 0, то PC + 2 × offset → PC

Если С = 1, то выполняется следующая команда.

__Описание:__ Проверяется бит переноса (C) регистра состояния. Если он сброшен, то смещение (10-битное число со знаком), находящееся в младших битах слова команды, прибавляется к счётчику команд. Если бит C установлен, то выполняется команда, следующая за командой перехода. Команда JNC (переход по «нет переноса»/ «ниже») используется при сравнении чисел без знака (от 0 до 65535).

__Биты состояния:__ не изменяются

### JN

__Операция:__

Если N = 1, то PC + 2 × offset → PC

Если N = 0, то выполняется следующая команда.

__Описание:__ Проверяется бит отрицательного значения (N) регистра состояния. Если он установлен, то смещение (10-битное число со знаком), находящееся в младших битах слова команды, прибавляется к счётчику команд. Если бит N сброшен, то выполняется команда, следующая за командой перехода.

__Биты состояния:__ не изменяются

### JGE

__Операция:__

Если (N .XOR. V) = 0, то PC + 2 × offset → PC

Если (N .XOR. V) = 1, то выполняется следующая команда.

__Описание:__ Проверяются биты переполнения (V) и отрицательного значения (N) регистра состояния. Если установлены или сброшены оба бита, то смещение (10-битное число со знаком), находящееся в младших битах слова команды, прибавляется к счётчику команд. Если установлен только один бит, то выполняется команда, следующая за командой перехода. Эта команда используется при сравнении чисел со знаком.

__Биты состояния:__ не изменяются

### JL

__Операция:__

Если (N .XOR. V) = 1, то PC + 2 × offset → PC

Если (N .XOR. V) = 0, то выполняется следующая команда.

__Описание:__ Проверяются биты переполнения (V) и отрицательного значения (N) регистра состояния. Если установлен только один из битов, то смещение (10-битное число со знаком), находящееся в младших битах слова команды, прибавляется к счётчику команд. Если установлены или сброшены оба бита, то выполняется команда, следующая за командой перехода. Эта команда используется при сравнении чисел со знаком.

__Биты состояния:__ не изменяются

### JMP

__Операция:__ PC + 2 × offset → PC

__Описание:__ Смещение (10-битное число со знаком), хранящееся в младших битах слова команды, прибавляется к счётчику команд.

__Биты состояния:__ не изменяются
